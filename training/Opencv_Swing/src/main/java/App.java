import matmath.ConcurrentMatMath;
import org.opencv.core.*;
import org.opencv.videoio.VideoCapture;
import robogui.RoboGui;

import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

    static boolean running = true;

    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }

    public static void main(String[] args) {
        System.out.println("Welcome to OpenCV " + Core.VERSION);
        Mat m = new Mat(5, 10, CvType.CV_8UC1, new Scalar(0));
        System.out.println("OpenCV Mat: " + m);
        Mat mr1 = m.row(1);
        mr1.setTo(new Scalar(1));
        Mat mc5 = m.col(5);
        mc5.setTo(new Scalar(5));
        System.out.println("OpenCV Mat data:\n" + m.dump());

        VideoCapture capt = new VideoCapture();
        System.out.println("Opening Capture");
        capt.open(0);
        System.out.println("Opened Capture");

        RoboGui.getInstance().setAllClosed(() -> running = false);
        RoboGui.debug = true;

        RoboGui.getInstance().addWindowListener("MotionFrame", new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent e) {
                RoboGui.getInstance().close("MotionFrame");
            }
        });

        Mat img = new Mat();
        Mat shiftImg;
        Mat filterImg;
        ConcurrentMatMath cmm;
        int shift = 0;
        capt.read(img);
        shiftImg = img.clone();
        filterImg = img.clone();
        while(running){
            cmm = new ConcurrentMatMath(8);
            capt.read(img);
            final int currShift = shift += 2;
            if(shift == img.width()){
                shift = 0;
            }
            cmm.mutateMat((x, y, ci) ->
                    ci[1].put(y, x, ci[0].get(y, (x + currShift) % ci[0].width()))
                    , img, shiftImg);
            cmm = new ConcurrentMatMath(8);
            /*cmm.mutateMat((x, y, ci) ->
            {
                if(x != 0 && x != ci[0].width() - 1 && y != 0 && y != ci[0].height() - 1) {
                    double[] pixel = ci[0].get(y, x);
                    boolean bright = true;
                    for (double c : pixel) {
                        if (c < 200) {
                            bright = false;
                        }
                    }
                    if (!bright) {
                        bright = false;
                        for (int a = -1; a < 2; a += 2) {
                            for (int b = -1; b < 2; b += 2) {
                                pixel = ci[0].get(y + b, x + a);
                                for (double c : pixel) {
                                    if (c > 200) {
                                        bright = true;
                                    }
                                }
                            }
                        }
                        if (bright) {
                            ci[1].put(y, x, new double[]{255.0, 64.0, 64.0});
                        } else {
                            ci[1].put(y, x, ci[0].get(y, x));
                        }
                    } else {
                        ci[1].put(y, x, ci[0].get(y, x));
                    }
                }else{
                    ci[1].put(y, x, ci[0].get(y, x));
                }
            }, shiftImg, filterImg);*/
            cmm.mutateMat((x, y, ci) -> {
                double[] pixel = ci[0].get(y, x);
                double sum = 0;
                for(double c : pixel){
                    sum += c;
                }
                ci[0].put(y, x, new double[]{sum / 3, sum / 3, sum / 3});
            }, shiftImg);
            RoboGui.getInstance().showExists("MotionFrame", shiftImg);
        }

        capt.release();
        RoboGui.getInstance().close();
    }
}
